

======================================
저장한 시간: 2025-03-18 오후 3:47:14 화요일
======================================

// ==================================================================
//  - 3 / 18 -
// ------------------------------------------------------------------
// 많은 개수의 자료를 처리 - file에 저장하고 읽어오기
// ------------------------------------------------------------------

#include <iostream>
#include<algorithm>  //여기있는 기능을 코딩하면 안된다
#include "save.h"
#include <random>
#include<print>
#include <array> //stl 시퀸스 드라이버 중 하나

#include<fstream>
//#include<string>

using namespace std;  //기본적으로 하지 말 것, 팀원들과 상의 하에 사용

default_random_engine dre{}; 
uniform_int_distribution uid{0, 999'9999}; 

// 파일 "int 1000개.txt" 에는 int 값 1000개가 text 모드로 기록되어 있다.
//메모리로 읽어 와라, 읽어온 값을 화면에 출력하라 

//--------
int main()
//--------
{
	
	array<int, 1000> a; 

	ifstream in{ "int 1000개.txt" };

	//cout << *max_element(istream_iterator<int>{in}, {}) << endl;

	int i = 0;
	while (in >> a[i++]);

	cout << *max_element( a.begin(), a.end() ) <<endl;

	save("main.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 3:56:06 화요일
======================================

// ==================================================================
//  - 3 / 18 -
// ------------------------------------------------------------------
// 많은 개수의 자료를 처리 - file에 저장하고 읽어오기
// ------------------------------------------------------------------

#include <iostream>
#include<algorithm>  //여기있는 기능을 코딩하면 안된다
#include "save.h"
#include <random>
#include<print>
#include <array> //stl 시퀸스 드라이버 중 하나

#include<fstream>
//#include<string>

using namespace std;  //기본적으로 하지 말 것, 팀원들과 상의 하에 사용

default_random_engine dre{}; 
uniform_int_distribution uid{0, 999'9999}; 

// 파일 "int 1000개.txt" 에는 int 값 1000개가 text 모드로 기록되어 있다.
//메모리로 읽어 와라, 읽어온 값을 화면에 출력하라 

//--------
int main()
//--------
{
	
	array<int, 1000> a{10}; //첫 값만 초기화
	a.fill(10); // 모든 값 초기화 


	for (int num : a)
		print("{:3}",num);

	ifstream in{ "int 1000개.txt" };

	copy(istream_iterator<int>{in} /*고급입력(int가 아니거나 형식에 맞지 않는다면 중간에 읽기 동작을 정지함(고급 입력은 좋은것이 아님))*/, {}, a.begin());

	/*int i = 0;
	while (in >> a[i++]);*/

	cout << *max_element( a.begin(), a.end() ) <<endl;

	save("main.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 4:09:02 화요일
======================================

// ==================================================================
//  - 3 / 18 -
// ------------------------------------------------------------------
// 정렬
// ------------------------------------------------------------------

#include <iostream>
#include<algorithm>  //여기있는 기능을 코딩하면 안된다
#include "save.h"
#include <random>
#include<print>
#include <array> //stl 시퀸스 드라이버 중 하나
#include<ranges> //최신정렬

#include<fstream>
//#include<string>

using namespace std;  //기본적으로 하지 말 것, 팀원들과 상의 하에 사용

default_random_engine dre{}; 
uniform_int_distribution uid{0, 999'9999}; 

// 파일 "int 1000개.txt" 에는 int 값 1000개가 text 모드로 기록되어 있다.
//메모리로 읽어 와라, 읽어온 값을 화면에 출력하라 

//--------
int main()
//--------
{
	
	array<int, 1000> a{10}; //첫 값만 초기화  //array<int, 1000> a 와 int a[1000]는 메모리 상 같다  
	// 특징 빈틈없이 물리적으로 연속되어 있다.(continuous (시간의 연속성) ,contiguous (공간의 연속성)) ->stl의 필수
	a.fill(10); // 모든 값 초기화 

	// 랜덤 억세싱 -> 둘 다 동일한 시간에 엑세스 한다

	ifstream in{ "int 1000개.txt" };

	copy(istream_iterator<int>{in} /*고급입력(int가 아니거나 형식에 맞지 않는다면 중간에 읽기 동작을 정지함(고급 입력은 좋은것이 아님))*/, {}, a.begin());

	/*int i = 0;
	while (in >> a[i++]);*/

	cout << *max_element( a.begin(), a.end() ) <<endl;
	//표준 반복자

	//cout << *max_element(a.begin(), a.end()) << endl; //과거의 정렬
	ranges::sort(a); //기본 오름차순 정렬 // 최신의 정렬
	for (int num : a)
		print("{:8}", num);

	save("main.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 4:27:03 화요일
======================================

// ==================================================================
//  - 3 / 18 -
// ------------------------------------------------------------------
// 많은 개수의 자료를 처리하기 - 파일 입출력
//                             - 바이너리 모드와 저수준 입출력 
// ------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include<array>
#include <bitset>

using namespace std;  //기본적으로 하지 말 것, 팀원들과 상의 하에 사용

// 파일 "int 1000개.txt" 에는 int 값 1000개가 text 모드로 기록되어 있다.
// 질문: 파일에서 저장한 바이트 수를 알아본다 - 8250 바이트 사용

//--------
int main()
//--------
{
	array<int, 1000> a;
	cout << "a가 사용하는 크기 - " << sizeof a << endl;

	int num{ 0x01020304 };

	bitset<32> binary( num );
	//little endian 으로 저장
	cout << " 2진수 - "   << binary << endl;;
	cout << "10진수 - "   << num << endl;
	cout << "16진수 - 0x" << hex << num << endl;


	save("main.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 4:30:28 화요일
======================================

// ==================================================================
//  - 3 / 18 -
// ------------------------------------------------------------------
// 많은 개수의 자료를 처리하기 - 파일 입출력
//                             - 바이너리 모드와 저수준 입출력 
// ------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include<array>
#include <bitset>
#include <fstream>

using namespace std;  //기본적으로 하지 말 것, 팀원들과 상의 하에 사용

// 1부터 시작하는 int값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 파일에 기록한다
// 파일 "int 천개를 메모리 그대로 기록" 에 기록
// ->메모리에 있는 비트 그대로 파일에 기록한다

//--------
int main()
//--------
{
	array<int, 1000> a;
	int i=0;
	a.fill(i++);

	ofstream out{ "int 천개를 메모리 그대로 기록" };

	save("main.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 4:30:58 화요일
======================================

// ==================================================================
//  - 3 / 18 -
// ------------------------------------------------------------------
// 많은 개수의 자료를 처리하기 - 파일 입출력
//                             - 바이너리 모드와 저수준 입출력 
// ------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include<array>
#include <bitset>
#include <fstream>

using namespace std;  //기본적으로 하지 말 것, 팀원들과 상의 하에 사용

// 1부터 시작하는 int값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 파일에 기록한다
// 파일 "int 천개를 메모리 그대로 기록" 에 기록
// ->메모리에 있는 비트 그대로 파일에 기록한다

//--------
int main()
//--------
{
	array<int, 1000> a;
	int i=0;
	a.fill(i++);

	for (int num : a)
		cout << num << endl;

	ofstream out{ "int 천개를 메모리 그대로 기록" };

	save("main.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 4:33:18 화요일
======================================

// ==================================================================
//  - 3 / 18 -
// ------------------------------------------------------------------
// 많은 개수의 자료를 처리하기 - 파일 입출력
//                             - 바이너리 모드와 저수준 입출력 
// ------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include<array>
#include <bitset>
#include <fstream>

using namespace std;  //기본적으로 하지 말 것, 팀원들과 상의 하에 사용

// 1부터 시작하는 int값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 파일에 기록한다
// 파일 "int 천개를 메모리 그대로 기록" 에 기록
// ->메모리에 있는 비트 그대로 파일에 기록한다

//--------
int main()
//--------
{
	array<int, 1000> a;
	int i{};
	for ( int& num: a)
		num = ++i;

	for (int num : a)
		cout << num << endl;

	ofstream out{ "int 천개를 메모리 그대로 기록" };

	save("main.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 4:35:36 화요일
======================================

// ==================================================================
//  - 3 / 18 -
// ------------------------------------------------------------------
// 많은 개수의 자료를 처리하기 - 파일 입출력
//                             - 바이너리 모드와 저수준 입출력 
// ------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include <array>
#include <bitset>
#include <fstream>
#include <numeric>

using namespace std;

// 1부터 시작하는 int값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 파일에 기록한다
// 파일 "int 천개를 메모리 그대로 기록" 에 기록
// ->메모리에 있는 비트 그대로 파일에 기록한다

//--------
int main()
//--------
{
	array<int, 1000> a;
	
	iota(a.begin(), a.end(), 1);

	for (int num : a)
		cout << num << endl;

	ofstream out{ "int 천개를 메모리 그대로 기록" };

	save("main.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 4:41:12 화요일
======================================

// ==================================================================
//  - 3 / 18 -
// ------------------------------------------------------------------
// 많은 개수의 자료를 처리하기 - 파일 입출력
//                             - 바이너리 모드와 저수준 입출력 
// ------------------------------------------------------------------

#include <iostream>
#include <array>
#include <bitset>
#include <fstream>
#include <numeric>

#include "save.h"
using namespace std;

// 1부터 시작하는 int값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 파일에 기록한다
// 파일 "int 천개를 메모리 그대로 기록" 에 기록
// ->메모리에 있는 비트 그대로 파일에 기록한다

//--------
int main()
//--------
{
	array<int, 1000> a;
	
	iota(a.begin(), a.end(), 1); //1부터 채워 줌 


	for (int num : a)
		cout << num << endl;


	//저수준 함수로 기록한다

	//stack,data , free store 중에 메모리가 만들어 진다

	ofstream out{ "int 천개를 메모리 그대로 기록" };

	out.write( (char*)a.data(), sizeof(int) * a.size());

	save("main.cpp");
}

======================================
저장한 시간: 2025-03-18 오후 4:56:09 화요일
======================================

// ------------------------------------------------------------
//  - 3 / 18 -
// ------------------------------------------------------------
// 많은 개수의 자료를 처리하기 - 파일 입출력
//                             - 바이너리 모드와 저수준 입출력 
// ------------------------------------------------------------

#include <iostream>
#include <array>
#include <bitset>
#include <fstream>
#include <numeric>

#include "save.h"
using namespace std;

// 1부터 시작하는 int값 1000개를 저수준 출력함수를 사용하여 메모리 크기 그대로 파일에 기록한다
// 파일 "int 천개를 메모리 그대로 기록" 에 기록
// ->메모리에 있는 비트 그대로 파일에 기록한다

//--------
int main()
//--------
{
	array<int, 1000> a;
	//a.fill(10); // 타자기에서 0x0a = line feed , 0x0d = carrage return 을 위한 즉 파일이 저 숫자에선 임의로 바이트를 설정해 버린다
	
	iota(a.begin(), a.end(), 1); //1부터 채워 줌 
	

	/*for (int num : a)
		cout << num << endl;*/


	//저수준 함수로 기록한다

	//stack,data , free store 중에 메모리가 만들어 진다

	ofstream out{ "int 천개를 메모리 그대로 기록", ios::binary }; //바이트의 메모리를 그대로 쓴다

	out.write( (char*)a.data(), sizeof(int) * a.size());

	save("main.cpp");
}