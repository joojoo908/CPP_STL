//-----------------------------------------------------------------------------
// STL 중간시험
//-----------------------------------------------------------------------------
// 환경 - VS 17.12.4 이상, C++언어 표준 - /std:c++latest, 미리보기Release x64
// 헤더 파일을 추가할 필요는 없다.
// 각 문제에서 요구하는 답을 구분하여 적어라.	
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <memory>
#include <array>
#include <vector>
#include <algorithm>
#include <numeric>
#include <string>
using namespace std;


//-----------------------------------------------------------------------------
// Test는 num개의 int를 free-store에 확보한 contiguous 메모리에 저장한다.
//-----------------------------------------------------------------------------

class Test {
public:
	Test() = default;

	void show() const {
		cout << num << " - ";
		for (int i = 0; i < 3; ++i)
			cout << p[i] << " ";
		cout << endl;
	}

private:
	int num{};					// free-store에 저장한 int의 개수	
	unique_ptr<int[]> p{};		// num개의 int가 저장되어 있는 contiguous 메모리를 관리하는 포인터


	/*Test(const Test& other)
		: num{ other.num } {

		p.reset();
		p = make_unique<int[]>(num);
		memcpy(p.get(), other.p.get(), num);
	}

	Test& operator=(Test& other) {
		if (this == &other) {
			return *this;
		}

		p.reset();
		p = make_unique<int[]>(num);
		memcpy(p.get(), other.p.get(), num);
	}*/

public:

	int max() {
		return *max_element(&p[0], &p[num]);
	}

	Test(Test&&) noexcept = default;
	Test& operator=(Test&&) noexcept = default;

	Test(const Test& other) : num{ other.num } {
		// 깊은 복사 수행
		p = make_unique<int[]>(other.num);
		memcpy(p.get(), other.p.get(), other.num);
		// 나머지 멤버 복사
	}

	// 복사 대입 연산자도 필요
	Test& operator=(const Test& other) {
		if (this == &other) return *this;
		num = other.num;
		p = make_unique<int[]>(other.num);
		memcpy(p.get(), other.p.get(), other.num);
		return *this;
	}

	friend ostream& operator<<(ostream& os, const Test& t) {
		os << t.num << " ";
		for (int i = 0; i < t.num; ++i) {
			os << t.p[i] << " ";
			if (0 == (i % 12))
				os << '\n';
		}
		return os;
	}
	friend istream& operator>>(istream& is, Test& t) {
		is >> t.num;
		t.p = make_unique<int[]>(t.num);  // 자료형에 따라 수정
		for (int i = 0; i < t.num; ++i) {
			is >> t.p[i];
		}
		return is;
	}

};

//-----------------------------------------------------------------------------
// main에 있는 문제를 순서대로 해결하며 요구하는 답을 답지에 적어 제출한다.
//-----------------------------------------------------------------------------

//---------
int main()
//---------
{
	ifstream in{ "시험.dat" };
	if (not in) {
		cout << "파일을 열 수 없습니다" << endl;
		return 20250424;
	}
	vector<Test> v;
	Test t;
	while (in >> t) {
		//t.show();

		v.push_back(t);
	}
	cout << v.size() << endl;
	//-------------------------------------------------------------------------
	// [문제 1] 파일 "시험.dat"에 저장된 Test 객체를 읽어 컨테이너에 저장하라.
	//-------------------------------------------------------------------------
	// "시험.dat" 파일은 text 모드로 열었다.
	// Test 객체는 << 연산자를 사용하여 기록하였다.
	// Test 객체가 몇 개인지는 파일을 읽어봐야 알 수 있는 상황이다.
	// 읽기 위해 추가한 내용을 답지에 적어라.
	// 모두 몇 개를 읽었는지 화면에 출력하고 답지에도 적어라. 
	//-------------------------------------------------------------------------
	// 답지에는 다음 내용을 적으면 된다.
	// - 사용한 컨테이너와 이유											(10)
	// - 읽기 위해 추가한 Test의 멤버함수와 관련 함수	 				(30+)
	// - 실제 읽어서 저장하는 코드										(10)
	// - 개수를 화면에 출력하는 코드와 출력된 내용						(10)
	//-------------------------------------------------------------------------







	//-------------------------------------------------------------------------
	// [문제 2] 각 Test 객체에 저장된 int값 중에 가장 큰 값을 찾는 함수 max를 
	// 작성하라.
	//-------------------------------------------------------------------------
	// 답지에 함수 max의 정의를 적어라.									(10)
	//-------------------------------------------------------------------------
	// 다음과 같은 형식의 코드가 문제 없도록 하자.
	//-------------------------------------------------------------------------


	// int 최대값 = 컨테이너[ 0 ].max( );

	// 이와 같은 형식으로 max를 사용한다
	// 이 코드에서 컨테이너는 [문제 1]에서 만든 컨테이너이다.


	// [ 문제 2 ]의 출력 예는 다음과 같다.
	//	첫 Test 객체의 최댓값 - 996461


	cout << v[0].max() << endl;




	//-------------------------------------------------------------------------
	// [문제 3] [문제 2]에서 작성한 max()를 사용하면 컨테이너에 저장된 
	// 모든 Test 객체의 최댓값을 알 수 있다.
	// 각 Test 객체의 최댓값들을 저장하는 컨테이너를 새로 만들어 
	// 여기에 모든 Test 객체의 최댓값을 저장하라.						
	//-------------------------------------------------------------------------

	// 여기에 들어갈 코드를 답지에 적어라.								(10)		

	vector<int> max_v;
	for (Test test : v) {
		test.show();
		int i = test.max();
		max_v.push_back(i);
	}

	// [ 문제 3 ]의 출력 예는 다음과 같다
	// [문제 3]에서 만든 컨테이너에 저장된 최댓값들 - 앞에서 부터 10개만 출력
	// 996461 996135 981724 990110 993535 987983 978682 999080 974756 994505


	//-------------------------------------------------------------------------
	// [문제 4] sort를 사용하여 [문제 3]의 컨테이너에 저장된 최댓값을 
	// 홀수와 짝수로 분리하라.
	// 컨테이너를 처음부터 순회할때 홀수가 먼저 나온 후에 짝수가 나와야 한다.
	//-------------------------------------------------------------------------

	// 여기에 들어갈 sort 코드를 답지에 적어라.							(10+)

	sort(max_v.begin(), max_v.end(), [](const int& a, const int& b) {
		return (a&1) > (b&1);
		});

	for (int i : max_v) {
		cout << i << "  " << endl;
	}

	// [ 문제 4 ]의 출력 예는 다음과 같다
	// 컨테이너에 저장된 최댓값들을 홀수와 짝수로 분리 - 앞에서 부터 10개만 출력
	// 980999 995213 979767 797537 992907 986969 991953 971227 998041 996081





	//-------------------------------------------------------------------------
	// [문제 5] [문제 1]에서 만든 컨테이너에 저장된 Test 객체를 predicate을
	// 사용하지 않더라도 Test 객체의 최댓값 기준으로 오름차순 정렬되게 하고
	// 싶다. 
	// 어떻게 하면 되는 지 설명하라. (설명만 할 것)						(10)	 
	//-------------------------------------------------------------------------

	// sort( [문제 1]컨테이너.begin( ), [문제 1]컨테이너.end( ) );

	// 이와 같은 형식으로 코딩하면 최댓값 기준으로 오름차순 정렬되어야 한다.




	//-------------------------------------------------------------------------
	// [문제 6] [문제 5]의 sort가 충분히 빠르게 실행된다고 생각하는가?  
	// 더 빠르게 실행될 방법은 없는가?  
	// 이미 빠르다고 생각하거나 더 빠르게 할 방법이 있다면 이유를 설명하라.	(10)
	//-------------------------------------------------------------------------
}